<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sinfonía Visual (Mente Musical)</title>
    <style>
        :root { --cursor-size: 10px; --cursor-bg: white; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes reveal {
            from { opacity: 0; transform: translateY(30px) scale(0.98); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; cursor: none; background-color: #000; }

        #background-video, #particle-canvas, #drawing-canvas {
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
        }

        #background-video { z-index: 1; filter: blur(50px) brightness(0.6); object-fit: cover; animation: fadeIn 1.5s ease-out; }
        #particle-canvas { z-index: 2; }
        #drawing-canvas { z-index: 4; mix-blend-mode: difference; pointer-events: none; }
        
        .perspective-wrapper {
            display: flex; justify-content: center; align-items: center;
            height: 100%;
            perspective: 1500px;
            position: relative;
            z-index: 3;
        }

        .video-container {
            position: relative;
            width: 640px; max-width: 90%;
            transform-style: preserve-3d;
            transition: transform 0.1s linear;
            animation: reveal 1s ease-out 0.5s backwards;
            pointer-events: none;
        }

        #video-card {
            position: relative; background-color: black;
            border-radius: 16px; overflow: hidden;
            box-shadow: 0 25px 60px rgba(0,0,0,0.4);
            transform: translateZ(0);
            transition: transform 0.4s ease, box-shadow 0.4s ease;
        }

        #video-card::after {
            content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(circle, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0) 70%);
            border-radius: 16px; opacity: 0;
            transform: scale(0.9);
            transition: opacity 0.4s ease, transform 0.4s ease;
            z-index: 2;
        }

        .video-container:hover #video-card { transform: translateY(-15px) scale(1.05); box-shadow: 0 40px 80px rgba(0,0,0,0.3); }
        .video-container:hover #video-card::after { opacity: 1; transform: scale(1); }
        #miVideo { display: block; width: 100%; height: auto; }
        
        #video-title {
            color: white; font-family: 'Helvetica Neue', 'Arial', sans-serif;
            font-weight: 400; font-size: 1.2rem;
            text-align: center; margin-top: 25px;
            opacity: 0.8; letter-spacing: 0.5px;
            transition: transform 0.4s ease, opacity 0.4s ease;
        }
        .video-container:hover #video-title { transform: translateY(-15px); opacity: 1; }
        
        #mute-btn {
            position: absolute; top: 20px; right: 20px;
            z-index: 10;
            background: none; border: none; padding: 0;
            cursor: none; width: 28px; height: 28px;
            pointer-events: auto;
        }
        #mute-btn svg {
            width: 100%; height: 100%; fill: white;
            mix-blend-mode: difference; 
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.5));
            transition: transform 0.2s;
        }
        
        #custom-cursor {
            position: fixed; width: var(--cursor-size); height: var(--cursor-size);
            background-color: var(--cursor-bg);
            border-radius: 50%; top: 0; left: 0;
            transform: translate(-50%, -50%);
            pointer-events: none; mix-blend-mode: difference;
            z-index: 9999;
            transition: transform 0.2s ease-out, opacity 0.5s ease-out;
        }
        #custom-cursor.hidden { opacity: 0; }
    </style>
</head>
<body>
    <div id="custom-cursor"></div>
    <canvas id="particle-canvas"></canvas>
    <canvas id="drawing-canvas"></canvas>

    <video id="background-video" loop muted disableRemotePlayback playsinline>
        <source src="Laufey.mp4" type="video/mp4">
    </video>

    <div class="perspective-wrapper" id="perspective-wrapper">
        <div class="video-container">
            <div id="video-card">
                <video id="miVideo" loop muted disableRemotePlayback playsinline>
                    <source src="Laufey.mp4" type="video/mp4">
                </video>
                <button id="mute-btn">
                    <svg viewBox="0 0 24 24"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/></svg>
                </button>
            </div>
            <div id="video-title">Pagina Hecho Para Pruebas :)</div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- CONFIGURACIÓN INICIAL ---
            const mainVideo = document.getElementById('miVideo');
            const bgVideo = document.getElementById('background-video');
            const muteBtn = document.getElementById('mute-btn');
            const videoContainer = document.querySelector('.video-container');
            const cursor = document.getElementById('custom-cursor');
            const drawingCanvas = document.getElementById('drawing-canvas');
            const particleCanvas = document.getElementById('particle-canvas');
            const dCtx = drawingCanvas.getContext('2d');
            const pCtx = particleCanvas.getContext('2d');

            // --- SINCRONIZACIÓN DE VIDEO ---
            const videoReady = (vid) => new Promise(resolve => vid.addEventListener('canplaythrough', resolve, { once: true }));
            Promise.all([videoReady(mainVideo), videoReady(bgVideo)]).then(() => {
                mainVideo.play(); bgVideo.play();
                const syncLoop = () => {
                    if (!mainVideo.paused) bgVideo.currentTime = mainVideo.currentTime;
                    requestAnimationFrame(syncLoop);
                };
                syncLoop();
            });

            // --- CURSOR INTELIGENTE Y 3D ---
            let cursorIdleTimer;
            document.addEventListener('mousemove', (e) => {
                cursor.classList.remove('hidden');
                clearTimeout(cursorIdleTimer);
                cursorIdleTimer = setTimeout(() => cursor.classList.add('hidden'), 2000);
                const { innerWidth, innerHeight } = window;
                videoContainer.style.transform = `rotateX(${(e.clientY / innerHeight - 0.5) * -20}deg) rotateY(${(e.clientX / innerWidth - 0.5) * 20}deg)`;
                cursor.style.left = `${e.clientX}px`; cursor.style.top = `${e.clientY}px`;
            });

            // --- DIBUJO ---
            let isDrawing = false, lastX = 0, lastY = 0;
            const resizeDrawingCanvas = () => { drawingCanvas.width = window.innerWidth; drawingCanvas.height = window.innerHeight; };
            resizeDrawingCanvas(); window.addEventListener('resize', resizeDrawingCanvas);
            dCtx.strokeStyle = '#FFF'; dCtx.lineWidth = 3; dCtx.lineCap = 'round'; dCtx.lineJoin = 'round';
            const getCoords = (e) => e.touches ? [e.touches[0].clientX, e.touches[0].clientY] : [e.clientX, e.clientY];
            const handleStart = (e) => { isDrawing = true; [lastX, lastY] = getCoords(e); };
            const handleEnd = () => isDrawing = false;
            const draw = (e) => {
                if (e.touches) e.preventDefault();
                if (!isDrawing) return;
                dCtx.beginPath(); dCtx.moveTo(lastX, lastY);
                const [currentX, currentY] = getCoords(e);
                dCtx.lineTo(currentX, currentY); dCtx.stroke();
                [lastX, lastY] = [currentX, currentY];
            };
            const fadeDrawingTrail = () => {
                dCtx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                dCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                requestAnimationFrame(fadeDrawingTrail);
            };
            
            // --- "MENTE MUSICAL" (CONDUCTOR Y ORQUESTA) ---
            let audioContext, analyser, source;
            let setupDone = false;

            const orchestra = {
                particles: [],
                scene: 'idle', // idle, heartbeat, stardust, supernova
                
                init() {
                    const resize = () => { particleCanvas.width = window.innerWidth; particleCanvas.height = window.innerHeight; };
                    resize(); window.addEventListener('resize', resize);
                },

                update(analysis) {
                    // Elige la escena basada en el análisis del Conductor
                    if (analysis.energy > 140) this.scene = 'supernova';
                    else if (analysis.energy > 80) this.scene = 'stardust';
                    else this.scene = 'heartbeat';

                    // Limpia el lienzo
                    pCtx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);

                    // Actualiza y dibuja la escena actual
                    switch(this.scene) {
                        case 'heartbeat': this.drawHeartbeat(analysis); break;
                        case 'stardust': this.manageStardust(analysis); break;
                        case 'supernova': this.manageSupernova(analysis); break;
                    }
                },

                drawHeartbeat(analysis) {
                    const size = 10 + (analysis.beat ? analysis.bass * 0.5 : 0);
                    pCtx.fillStyle = `rgba(255, 255, 255, ${0.5 + analysis.treble / 255})`;
                    pCtx.beginPath();
                    pCtx.arc(particleCanvas.width / 2, particleCanvas.height / 2, size, 0, Math.PI * 2);
                    pCtx.fill();
                },

                manageStardust(analysis) {
                    if (analysis.beat && this.particles.length < 150) {
                        for(let i=0; i<5; i++) this.particles.push(new Particle('stardust'));
                    }
                    this.updateAndDrawParticles(analysis);
                },

                manageSupernova(analysis) {
                    if (analysis.beat && this.particles.length < 300) {
                         for(let i=0; i<20; i++) this.particles.push(new Particle('supernova', analysis.bass));
                    }
                    this.updateAndDrawParticles(analysis);
                },

                updateAndDrawParticles(analysis) {
                    for (let i = this.particles.length - 1; i >= 0; i--) {
                        const p = this.particles[i];
                        p.update(analysis);
                        if (p.isDead()) {
                            this.particles.splice(i, 1);
                        } else {
                            p.draw(pCtx);
                        }
                    }
                }
            };
            
            const conductor = {
                beatCutOff: 0.85,
                lastBeat: 0,
                beatDetected: false,
                analyze(analyser) {
                    const bufferLength = analyser.frequencyBinCount;
                    const dataArray = new Uint8Array(bufferLength);
                    analyser.getByteFrequencyData(dataArray);

                    const bass = dataArray.slice(0, 5).reduce((a,b) => a+b) / 5;
                    const treble = dataArray.slice(100, 200).reduce((a,b) => a+b) / 100;
                    const energy = dataArray.reduce((a,b) => a+b) / bufferLength;

                    const beatThreshold = -0.005 * bufferLength + 1;
                    const normalized = Array.from(dataArray).map(v => v / 256);
                    const beat = normalized.reduce((sum, v) => sum + v, 0) / bufferLength > beatThreshold;
                    
                    this.beatDetected = false;
                    if(Date.now() - this.lastBeat > 100 && beat) {
                        this.beatDetected = true;
                        this.lastBeat = Date.now();
                    }

                    return { bass, treble, energy, beat: this.beatDetected };
                }
            };

            class Particle {
                constructor(type, bass = 0) {
                    this.type = type;
                    this.x = particleCanvas.width / 2;
                    this.y = particleCanvas.height / 2;
                    this.angle = Math.random() * Math.PI * 2;
                    this.radius = 1 + Math.random() * 2;
                    this.life = 1;

                    if (type === 'stardust') {
                        this.speed = 1 + Math.random() * 2;
                    } else if (type === 'supernova') {
                        this.speed = bass * 0.1 + Math.random() * 5;
                    }
                }

                update(analysis) {
                    this.life -= 0.01;
                    this.x += Math.cos(this.angle) * this.speed;
                    this.y += Math.sin(this.angle) * this.speed;
                    this.speed *= 0.98; // Friction
                }

                draw(ctx) {
                    ctx.globalAlpha = this.life;
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }

                isDead() {
                    return this.life <= 0;
                }
            }

            // --- BOTÓN PRINCIPAL Y ARRANQUE ---
            muteBtn.addEventListener('click', (e) => {
                if (setupDone) return;
                setupDone = true;
                e.stopPropagation();
                muteBtn.style.display = 'none';

                drawingCanvas.style.pointerEvents = 'auto';
                drawingCanvas.addEventListener('mousedown', handleStart);
                drawingCanvas.addEventListener('mousemove', draw);
                drawingCanvas.addEventListener('mouseup', handleEnd);
                drawingCanvas.addEventListener('mouseleave', handleEnd);
                drawingCanvas.addEventListener('touchstart', handleStart, { passive: false });
                drawingCanvas.addEventListener('touchmove', draw, { passive: false });
                drawingCanvas.addEventListener('touchend', handleEnd);
                fadeDrawingTrail();
                
                mainVideo.muted = false;

                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    source = audioContext.createMediaElementSource(mainVideo);
                    analyser = audioContext.createAnalyser();
                    source.connect(analyser);
                    analyser.connect(audioContext.destination);
                }
                audioContext.resume();
                orchestra.init();
                animate();
            });

            function animate() {
                const analysis = conductor.analyze(analyser);
                orchestra.update(analysis);
                requestAnimationFrame(animate);
            }
        });
    </script>
</body>
</html>
